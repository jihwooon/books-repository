# 자료 구조가 중요한 이유

<details>
<summary>자료구조는 왜 중요한 것일까?</summary>

* 자료 구조의 성능 측정은 연산에 필요한 단계 수를 구하는 게 핵심이다.
* 코드 품질은 여러가지 척도에서 평가 해 볼 수 있다. 한 가지 중요한 척도는 코드 유지 보수성이다.
* 우리가 여기서 봐야 할 것은 **코드 효율성**이다. 
* 목표를 달성하더라도 두 코드 중 어느 한 쪽이 더 빠르게 실행이 되는지 확인이 필요하다.
* 이것을 알기 위해서 **자료구조**를 알아야 하고 중요한 개념이다.
</details>

<details>
<summary>자료 구조란 정의란 무엇인가?</summary>

* 자료구조의 정의는 데이터를 **조직**방법이다.
* 데이터 조직이 코드의 실행 속도(성능)에 상당히 많이 영향을 미친다.
</details>

<details>
<summary>기초 자료 구조에서 배열이 왜 기본이 되는가?</summary>

* 배열은 자료구조에서 단순히 원소들의 리스트 역활을 한다
* 자료구조에서 배열의 **크기**는 데이터가 얼마나 들어 있는지 알려줍니다.
* 배열의 **인덱스**는 데이터가 배열의 어디에 있는지 알려주는 숫자 입니다.
</details>

<details>
<summary>자료구조에서 속도 측정은 어떻게 할까?</summary>

* 읽기 검색 삽입 삭제 와 같은 연산의 속도를 측정 할 때는 시간이 아닌 **단계**의 따라 속도를 측정 해 볼 수 있습니다.
* 시간은 하드웨어에 따라 시간이 달라짐으로 신뢰가 없습니다.
</details>

<details>
<summary>읽기 / 검색 / 삽입 / 삭제 은 자료구조에서 속도가 얼마나 걸릴까?</summary>

* **읽기** : 한 단계로 배열에서 읽을 수 있다.
	* 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
	* 컴퓨터는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록합니다.
* **검색** : 모든 메모리 주소에 한 번에 접근이 가능하지만 메모리 주소에 어떤 값이 있는지는 모르게 때문에 인덱스 0 부터 값을 찾을 때까지 단계를 걸처서 수를 구합니다.
* **삽입** : 배열의 위치에 따라 삽입의 효율성이 다릅니다.
	* 마지막 인덱스에 새값을 추가한다면 한 단계면 끝입니다.
	* 인덱스 중간에 추가하면 오른쪽으로 한 단계씩 옮긴다.
	* 최악의 시나리오는 맨 앞에 삽입 할 때 이다.
* **삭제** : 배열의 위치에 따라 삽입의 효율성이 다릅니다.
	* 마지막 인덱스에 값을 삭제한다면 한 단계면 끝입니다.
	* 인덱스 중간에 삭제하면 왼쪽으로 한 단계씩 옮긴다.
	* 최악의 시나리오는 맨 앞에 삭제하면 모든 원소들을 왼쪽으로 옮깁니다.
</details>

<details>
<summary>읽기와 검색의 차이는 무엇인가요?</summary>

* 읽기는 컴퓨터에 인덱스를 제공하고 그 인덱스에 들어 있는 값을 반환하라고 요청합니다.
* 검색은 컴퓨터에 값을 제공하고 그 값이 들어 있는 인덱스를 반환하라고 합니다.
</details>

<details>
<summary>집합: 한가지 규칙이 효율성을 달라지게 한다고 하는데 어떻게 달라지는가?</summary>

* 집합은 중복을 허용하지 않는 자료 구조이다.
* 일반 배열과 집합 배열의 차이는 중복 값의 삽입을 허용하지 않는다는 점이다.
* 읽기는 일반 배열과 동일하다.
* 삽입은 일반 배열과 다르다.
* 먼저 검색 한 후 중복이 없다는 걸 인지하면 삽입을 한다.
</details>

## Reference
1) 조직하다 : 특정한 목적을 달성하기 위하여 여러 개체나 요소를 모아서 체계 있는 집단을 이루다.

